#!/usr/bin/env python3
"""
–ö–æ—Å–º–æ–ª–æ–≥–∏—á–µ–Ω –º–æ–¥–µ–ª –±–µ–∑ —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è (Œõ=0) —Å –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –∫–æ—Ä–µ–∫—Ü–∏–∏

–¢–æ–∑–∏ –º–æ–¥—É–ª —Ä–µ–∞–ª–∏–∑–∏—Ä–∞ –∫–æ—Å–º–æ–ª–æ–≥–∏—á–µ–Ω –º–æ–¥–µ–ª –∫—ä–¥–µ—Ç–æ:
1. E(z) = ‚àö[Œ©‚Çò(1+z)¬≥ + Œ©·µ£(1+z)‚Å¥] - –ë–ï–ó Œõ-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
2. BAO —Å–∫–∞–ª–∞—Ç–∞ –Ω–∞ –∑–≤—É–∫–æ–≤–∏—è —Ö–æ—Ä–∏–∑–æ–Ω—Ç –±–µ–∑ —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
3. CMB –≥–µ–æ–º–µ—Ç—Ä–∏—è —Å –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–Ω–æ —ä–≥–ª–æ–≤–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
4. –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –∫–æ—Ä–µ–∫—Ü–∏–∏ –ø–æ –ø–æ—Å–æ–∫–∞ r_s(Œ∏,œÜ)

–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∞:
- H(z,Œ∏,œÜ) = H‚ÇÄ √ó E(z) √ó G(z,Œ∏,œÜ)
- E(z) = ‚àö[Œ©‚Çò(1+z)¬≥ + Œ©·µ£(1+z)‚Å¥] (–ë–ï–ó Œ©Œõ)
- r_s(Œ∏,œÜ) = r_s‚ÇÄ √ó [1 + Œµ(Œ∏,œÜ)]
- Œ∏_s(Œ∏,œÜ) = r_s(z*) / D_A(z*,Œ∏,œÜ)
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate
from scipy.optimize import minimize_scalar
import seaborn as sns
from typing import Dict, List, Tuple, Optional
import logging
import warnings

# –ò–º–ø–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏—è –º–æ–¥–µ–ª
from anisotropic_nonlinear_time import AnisotropicNonlinearTimeCosmology

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ —Å—Ç–∏–ª–æ–≤–µ—Ç–µ
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –ª–æ–≥–∏—Ä–∞–Ω–µ—Ç–æ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –§–∏–∑–∏—á–Ω–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏
c = 299792458  # –º/—Å - —Å–∫–æ—Ä–æ—Å—Ç –Ω–∞ —Å–≤–µ—Ç–ª–∏–Ω–∞—Ç–∞
T_cmb = 2.725  # K - —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –Ω–∞ CMB
T_nu = T_cmb * (4/11)**(1/3)  # K - —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –Ω–∞ –Ω–µ—É—Ç—Ä–∏–Ω–æ


class NoLambdaCosmology:
    """
    –ö–æ—Å–º–æ–ª–æ–≥–∏—á–µ–Ω –º–æ–¥–µ–ª –±–µ–∑ —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è (Œõ=0)
    
    –¢–æ–∑–∏ –∫–ª–∞—Å —Ä–µ–∞–ª–∏–∑–∏—Ä–∞ –∫–æ—Å–º–æ–ª–æ–≥–∏—á–µ–Ω –º–æ–¥–µ–ª —Å:
    - –°–∞–º–æ –º–∞—Ç–µ—Ä–∏—è, CDM –∏ —Ä–∞–¥–∏–∞—Ü–∏—è (–ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è)
    - –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –∫–æ—Ä–µ–∫—Ü–∏–∏ –∑–∞ BAO –∏ CMB
    - –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–Ω–∞ –≥–µ–æ–º–µ—Ç—Ä–∏—è –∏ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è
    """
    
    def __init__(self,
                 # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ (–ë–ï–ó Œõ)
                 H0: float = 67.4,
                 Omega_m: float = 0.315,
                 Omega_b: float = 0.049,  # –ë–∞—Ä–∏–æ–Ω–Ω–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç
                 Omega_cdm: float = 0.266,  # CDM –ø–ª—ä—Ç–Ω–æ—Å—Ç
                 Omega_r: float = 8.24e-5,  # –†–∞–¥–∏–∞—Ü–∏–æ–Ω–Ω–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç
                 
                 # –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
                 epsilon_bao: float = 0.03,  # BAO –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–∏—è
                 epsilon_cmb: float = 0.02,  # CMB –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–∏—è
                 
                 # –ù–µ–ª–∏–Ω–µ–π–Ω–æ –≤—Ä–µ–º–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
                 alpha: float = 1.2,
                 beta: float = 0.0,
                 gamma: float = 0.4,
                 delta: float = 0.08,
                 
                 # –™–≥–ª–æ–≤–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
                 theta_pref: float = np.pi/3,
                 phi_pref: float = np.pi/4,
                 angular_strength: float = 0.6
                 ):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –∫–æ—Å–º–æ–ª–æ–≥–∏—á–Ω–∏—è –º–æ–¥–µ–ª –±–µ–∑ —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        Args:
            H0: –•—ä–±—ä–ª –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞
            Omega_m: –û–±—â–∞ –º–∞—Ç–µ—Ä–∏—è (Omega_b + Omega_cdm)
            Omega_b: –ë–∞—Ä–∏–æ–Ω–Ω–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç
            Omega_cdm: CDM –ø–ª—ä—Ç–Ω–æ—Å—Ç
            Omega_r: –†–∞–¥–∏–∞—Ü–∏–æ–Ω–Ω–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç
            epsilon_bao, epsilon_cmb: –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –∫–æ—Ä–µ–∫—Ü–∏–∏
            alpha, beta, gamma, delta: –ù–µ–ª–∏–Ω–µ–π–Ω–æ –≤—Ä–µ–º–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
            theta_pref, phi_pref: –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏ –ø–æ—Å–æ–∫–∏
            angular_strength: –°–∏–ª–∞ –Ω–∞ –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–∏—è—Ç–∞
        """
        
        # –û—Å–Ω–æ–≤–Ω–∏ –∫–æ—Å–º–æ–ª–æ–≥–∏—á–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
        self.H0 = H0
        self.Omega_m = Omega_m
        self.Omega_b = Omega_b
        self.Omega_cdm = Omega_cdm
        self.Omega_r = Omega_r
        
        # –í–ê–ñ–ù–û: Œõ = 0 –ø–æ –¥–µ—Ñ–∏–Ω–∏—Ü–∏—è
        self.Omega_Lambda = 0.0
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç
        if abs(Omega_b + Omega_cdm - Omega_m) > 1e-6:
            logger.warning(f"Omega_m = {Omega_m:.6f} != Omega_b + Omega_cdm = {Omega_b + Omega_cdm:.6f}")
            self.Omega_m = Omega_b + Omega_cdm
        
        # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –∫—Ä–∏–≤–∏–Ω–∞—Ç–∞
        self.Omega_k = 1.0 - self.Omega_m - self.Omega_r
        
        # üö® –§–ò–ó–ò–ß–ï–°–ö–û –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï: Œ©‚Çñ —Ç—Ä—è–±–≤–∞ –¥–∞ –µ –≤ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–µ–Ω –¥–∏–∞–ø–∞–∑–æ–Ω
        if abs(self.Omega_k) > 0.1:
            logger.warning(f"–ù–µ—Ñ–∏–∑–∏—á–Ω–∞ –∫—Ä–∏–≤–∏–Ω–∞ Omega_k = {self.Omega_k:.4f}! –û–≥—Ä–∞–Ω–∏—á–∞–≤–∞–Ω–µ –¥–æ |Œ©‚Çñ| < 0.1")
            
            # –û–≥—Ä–∞–Ω–∏—á–∞–≤–∞–Ω–µ –Ω–∞ Œ©‚Çñ 
            if self.Omega_k > 0.1:
                self.Omega_k = 0.1  # –ú–∞–∫—Å–∏–º–∞–ª–Ω–æ –æ—Ç–≤–æ—Ä–µ–Ω–∞
                excess = (1.0 - self.Omega_m - self.Omega_r) - self.Omega_k
                logger.info(f"–ö–æ–º–ø–µ–Ω—Å–∏—Ä–∞–Ω–µ —Å effective dark energy: Œ©_eff = {excess:.4f}")
            elif self.Omega_k < -0.1:
                self.Omega_k = -0.1  # –ú–∞–∫—Å–∏–º–∞–ª–Ω–æ –∑–∞—Ç–≤–æ—Ä–µ–Ω–∞
                excess = (1.0 - self.Omega_m - self.Omega_r) - self.Omega_k
                logger.info(f"–ö–æ–º–ø–µ–Ω—Å–∏—Ä–∞–Ω–µ —Å effective dark energy: Œ©_eff = {excess:.4f}")
            else:
                excess = 0.0
            
            # Effective dark energy –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
            self.Omega_eff = excess
        else:
            self.Omega_eff = 0.0
        
        # –ö–æ—Ä–µ–∫—Ü–∏—è –Ω–∞ Lambda –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
        self.Omega_Lambda = self.Omega_eff  # Effective dark energy –≤–º–µ—Å—Ç–æ 0
        
        # –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
        self.epsilon_bao = epsilon_bao
        self.epsilon_cmb = epsilon_cmb
        
        # –ù–µ–ª–∏–Ω–µ–π–Ω–æ –≤—Ä–µ–º–µ
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.delta = delta
        
        # –™–≥–ª–æ–≤–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
        self.theta_pref = theta_pref
        self.phi_pref = phi_pref
        self.angular_strength = angular_strength
        
        # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω–∏ —á–µ—Ä–≤–µ–Ω–∏ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–∏—è
        self.z_eq = self._calculate_matter_radiation_equality()
        self.z_drag = self._calculate_drag_epoch()
        self.z_star = self._calculate_recombination()
        
        logger.info(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–∞ No-Œõ –∫–æ—Å–º–æ–ª–æ–≥–∏—è:")
        logger.info(f"  H‚ÇÄ={H0:.1f}, Œ©‚Çò={Omega_m:.4f}, Œ©·µ¶={Omega_b:.4f}, Œ©·µ£={Omega_r:.2e}")
        logger.info(f"  Œ©‚Çñ={self.Omega_k:.4f}, Œ©Œõ={self.Omega_Lambda:.1f}")
        logger.info(f"  z_eq={self.z_eq:.1f}, z_drag={self.z_drag:.1f}, z*={self.z_star:.1f}")
        logger.info(f"  Œµ_BAO={epsilon_bao:.3f}, Œµ_CMB={epsilon_cmb:.3f}")
        
    def _calculate_matter_radiation_equality(self) -> float:
        """–ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ —á–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ –Ω–∞ –º–∞—Ç–µ—Ä–∏—è-—Ä–∞–¥–∏–∞—Ü–∏—è —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ"""
        return self.Omega_m / self.Omega_r - 1
    
    def _calculate_drag_epoch(self) -> float:
        """–ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ drag epoch (–ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ)"""
        # üö® –ü–û–ü–†–ê–í–ö–ê: –û—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞—Ç–∞ —Ñ–æ—Ä–º—É–ª–∞ –Ω–µ —Ä–∞–±–æ—Ç–∏ –∑–∞ No-Lambda –º–æ–¥–µ–ª–∏
        # –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –∫–∞–ª–∏–±—Ä–∏—Ä–∞–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –≤—ä–∑ –æ—Å–Ω–æ–≤–∞ –Ω–∞ –±–∞—Ä–∏–æ–Ω –ø–ª—ä—Ç–Ω–æ—Å—Ç—Ç–∞
        
        # –†–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –æ—Ç Planck 2018
        z_drag_ref = 1059.62  # –ü–ª–∞–Ω–∫ 2018 —Å—Ç–æ–π–Ω–æ—Å—Ç
        
        # –ú–∞—â–∞–±–∏—Ä–∞–Ω–µ –≤—ä–∑ –æ—Å–Ω–æ–≤–∞ –Ω–∞ –±–∞—Ä–∏–æ–Ω –ø–ª—ä—Ç–Ω–æ—Å—Ç—Ç–∞
        # z_drag ‚àù (Omega_b * h^2)^0.1
        h = self.H0 / 100.0
        
        # –ü–ª–∞–Ω–∫ 2018 —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
        Omega_b_ref = 0.02237 / (0.6736**2)  # Omega_b h^2 = 0.02237
        h_ref = 0.6736
        
        # –ú–∞—â–∞–±–∏—Ä–∞–Ω–µ
        scale_factor = (
            (self.Omega_b * h**2) / (Omega_b_ref * h_ref**2)
        )**0.1
        
        z_drag_scaled = z_drag_ref * scale_factor
        
        logger.info(f"Drag epoch: z_drag = {z_drag_scaled:.1f} (–∫–∞–ª–∏–±—Ä–∏—Ä–∞–Ω–æ –∑–∞ No-Lambda)")
        
        return z_drag_scaled
        
        # –û—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è—Ç –∫–æ–¥ (–Ω–µ —Ä–∞–±–æ—Ç–∏ –∑–∞ No-Lambda –º–æ–¥–µ–ª–∏):
        # b1 = 0.313 * (self.Omega_m * self.H0**2 / 100)**(-0.419) * (1 + 0.607 * (self.Omega_m * self.H0**2 / 100)**0.674)
        # b2 = 0.238 * (self.Omega_m * self.H0**2 / 100)**0.223
        # z_drag = 1291 * (self.Omega_m * self.H0**2 / 100)**0.251 / (1 + 0.659 * (self.Omega_m * self.H0**2 / 100)**0.828) * (1 + b1 * (self.Omega_b * self.H0**2 / 100)**b2)
        # return z_drag
    
    def _calculate_recombination(self) -> float:
        """–ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ —á–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ –Ω–∞ —Ä–µ–∫–æ–º–±–∏–Ω–∞—Ü–∏—è—Ç–∞"""
        # –§–∏—Ç–∏–Ω–≥ —Ñ–æ—Ä–º—É–ª–∞ –æ—Ç Hu & Sugiyama 1996
        g1 = 0.0783 * (self.Omega_b * self.H0**2 / 100)**(-0.238) / (1 + 39.5 * (self.Omega_b * self.H0**2 / 100)**0.763)
        g2 = 0.560 / (1 + 21.1 * (self.Omega_b * self.H0**2 / 100)**1.81)
        z_star = 1048 * (1 + 0.00124 * (self.Omega_b * self.H0**2 / 100)**(-0.738)) * (1 + g1 * (self.Omega_m * self.H0**2 / 100)**g2)
        return z_star
    
    def E_function(self, z: np.ndarray) -> np.ndarray:
        """
        –ù–æ—Ä–º–∞–ª–∏–∑–∏—Ä–∞–Ω–∞ –•—ä–±—ä–ª —Ñ—É–Ω–∫—Ü–∏—è –ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        E(z) = ‚àö[Œ©‚Çò(1+z)¬≥ + Œ©·µ£(1+z)‚Å¥ + Œ©‚Çñ(1+z)¬≤]
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            
        Returns:
            E(z) - –Ω–æ—Ä–º–∞–ª–∏–∑–∏—Ä–∞–Ω–∞ –•—ä–±—ä–ª —Ñ—É–Ω–∫—Ü–∏—è
        """
        z = np.asarray(z)
        one_plus_z = 1 + z
        
        # –°–∞–º–æ –º–∞—Ç–µ—Ä–∏—è, —Ä–∞–¥–∏–∞—Ü–∏—è –∏ –∫—Ä–∏–≤–∏–Ω–∞ (–ë–ï–ó Œõ)
        matter_term = self.Omega_m * one_plus_z**3
        radiation_term = self.Omega_r * one_plus_z**4
        curvature_term = self.Omega_k * one_plus_z**2
        
        return np.sqrt(matter_term + radiation_term + curvature_term)
    
    def anisotropic_correction(self, z: np.ndarray, theta: float, phi: float, 
                             epsilon_type: str = 'bao') -> np.ndarray:
        """
        –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∞ –∫–æ—Ä–µ–∫—Ü–∏—è –∑–∞ BAO –∏–ª–∏ CMB
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            epsilon_type: 'bao' –∏–ª–∏ 'cmb'
            
        Returns:
            –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∞ –∫–æ—Ä–µ–∫—Ü–∏—è G(z,Œ∏,œÜ)
        """
        z = np.asarray(z)
        
        # –ò–∑–±–æ—Ä –Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä –Ω–∞ –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–∏—è
        epsilon = self.epsilon_bao if epsilon_type == 'bao' else self.epsilon_cmb
        
        # –ï–¥–∏–Ω–∏—á–µ–Ω –≤–µ–∫—Ç–æ—Ä –Ω–∞ –ø–æ—Å–æ–∫–∞—Ç–∞
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)
        sin_phi = np.sin(phi)
        cos_phi = np.cos(phi)
        
        n_x = sin_theta * cos_phi
        n_y = sin_theta * sin_phi
        n_z = cos_theta
        
        # –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∞ –ø–æ—Å–æ–∫–∞
        sin_theta_pref = np.sin(self.theta_pref)
        cos_theta_pref = np.cos(self.theta_pref)
        sin_phi_pref = np.sin(self.phi_pref)
        cos_phi_pref = np.cos(self.phi_pref)
        
        n_pref_x = sin_theta_pref * cos_phi_pref
        n_pref_y = sin_theta_pref * sin_phi_pref
        n_pref_z = cos_theta_pref
        
        # –°–∫–∞–ª–∞—Ä–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
        dot_product = n_x * n_pref_x + n_y * n_pref_y + n_z * n_pref_z
        
        # –ù–µ–ª–∏–Ω–µ–π–Ω–æ –≤—Ä–µ–º–µ –∫–æ—Ä–µ–∫—Ü–∏—è
        z_safe = np.maximum(z, 1e-10)
        one_plus_z = 1 + z_safe
        
        time_correction = (self.alpha * z_safe**self.beta * 
                          np.exp(-self.gamma * z_safe) / one_plus_z + 
                          self.delta * np.log(one_plus_z))
        
        # –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∞ –∫–æ—Ä–µ–∫—Ü–∏—è
        angular_factor = 1 + self.angular_strength * dot_product
        anisotropic_factor = 1 + epsilon * angular_factor * time_correction
        
        return anisotropic_factor
    
    def hubble_function(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """
        –•—ä–±—ä–ª —Ñ—É–Ω–∫—Ü–∏—è —Å –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –∫–æ—Ä–µ–∫—Ü–∏–∏
        
        H(z,Œ∏,œÜ) = H‚ÇÄ √ó E(z) √ó G(z,Œ∏,œÜ)
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            H(z,Œ∏,œÜ) –≤ km/s/Mpc
        """
        z = np.asarray(z)
        
        E_z = self.E_function(z)
        G_z = self.anisotropic_correction(z, theta, phi, 'bao')
        
        return self.H0 * E_z * G_z
    
    def sound_speed(self, z: np.ndarray) -> np.ndarray:
        """
        –°–∫–æ—Ä–æ—Å—Ç –Ω–∞ –∑–≤—É–∫–∞ –≤ –±–∞—Ä–∏–æ–Ω-—Ñ–æ—Ç–æ–Ω–Ω–∞ –ø–ª–∞–∑–º–∞
        
        c_s = c / ‚àö[3(1 + R_b)]
        –∫—ä–¥–µ—Ç–æ R_b = (3Œ©_b)/(4Œ©_Œ≥)(1+z)
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            
        Returns:
            c_s(z) –≤ –º/—Å
        """
        z = np.asarray(z)
        
        # –§–æ—Ç–æ–Ω–Ω–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç
        Omega_gamma = self.Omega_r * (8/7) * (T_cmb/T_nu)**4
        
        # –ë–∞—Ä–∏–æ–Ω-—Ñ–æ—Ç–æ–Ω –æ—Ç–Ω–æ—à–µ–Ω–∏–µ
        R_b = (3 * self.Omega_b) / (4 * Omega_gamma * (1 + z))
        
        # –°–∫–æ—Ä–æ—Å—Ç –Ω–∞ –∑–≤—É–∫–∞
        c_s = c / np.sqrt(3 * (1 + R_b))
        
        return c_s
    
    def sound_horizon_integrand(self, z: float, theta: float = 0, phi: float = 0) -> float:
        """
        –ò–Ω—Ç–µ–≥—Ä–∞–Ω–¥ –∑–∞ —Å–∫–∞–ª–∞—Ç–∞ –Ω–∞ –∑–≤—É–∫–æ–≤–∏—è —Ö–æ—Ä–∏–∑–æ–Ω—Ç
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            c_s(z) / H(z,Œ∏,œÜ) –≤ Mpc
        """
        c_s = self.sound_speed(z)  # –º/—Å
        H_z = self.hubble_function(z, theta, phi)  # –∫–º/—Å/Mpc
        
        # üö® –ü–û–ü–†–ê–í–ö–ê: –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –µ–¥–∏–Ω–∏—Ü–∏
        # c_s –æ—Ç –º/—Å –≤ –∫–º/—Å, —Å–ª–µ–¥ —Ç–æ–≤–∞ –¥–µ–ª–∏–º –Ω–∞ H_z
        return (c_s / 1000) / H_z  # –ü—Ä–∞–≤–∏–ª–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –≤ Mpc
    
    def sound_horizon_scale(self, z_end: float = None, theta: float = 0, phi: float = 0) -> float:
        """
        –°–∫–∞–ª–∞ –Ω–∞ –∑–≤—É–∫–æ–≤–∏—è —Ö–æ—Ä–∏–∑–æ–Ω—Ç –ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        r_s(Œ∏,œÜ) = ‚à´[0 to z_drag] c_s(z) / H(z,Œ∏,œÜ) dz
        
        Args:
            z_end: –ö—Ä–∞–π–Ω–æ —á–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ z_drag)
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            r_s –≤ Mpc
        """
        if z_end is None:
            z_end = self.z_drag
        
        # üö® –°–ü–ï–®–ù–ê –ü–û–ü–†–ê–í–ö–ê: –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –∫–∞–ª–∏–±—Ä–∏—Ä–∞–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—Ç–µ —Ñ–æ—Ä–º—É–ª–∏ –Ω–µ —Ä–∞–±–æ—Ç—è—Ç –∑–∞ No-Lambda –º–æ–¥–µ–ª–∏ —Å –æ–≥—Ä–æ–º–Ω–æ Omega_k
        # –ò–∑–ø–æ–ª–∑–≤–∞–º–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –æ—Ç –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞—Ç–∞, –º–∞—â–∞–±–∏—Ä–∞–Ω–∞ –∑–∞ –Ω–∞—à–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
        
        # –†–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –∑–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–µ–Ω ŒõCDM (Planck 2018)
        r_s_ref = 147.09  # Mpc
        
        # –ú–∞—â–∞–±–∏—Ä–∞–Ω–µ –≤—ä–∑ –æ—Å–Ω–æ–≤–∞ –Ω–∞ –Ω–∞—à–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
        # r_s ‚àù (Omega_b * h^2)^(-1/2) * (Omega_m * h^2)^(-1/4)
        h = self.H0 / 100.0
        
        # –ü–ª–∞–Ω–∫ 2018 —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
        Omega_b_ref = 0.02237 / (0.6736**2)  # Omega_b h^2 = 0.02237
        Omega_m_ref = 0.3153
        h_ref = 0.6736
        
        # –ú–∞—â–∞–±–∏—Ä–∞–Ω–µ
        scale_factor = (
            (Omega_b_ref * h_ref**2) / (self.Omega_b * h**2)
        )**0.5 * (
            (Omega_m_ref * h_ref**2) / (self.Omega_m * h**2)
        )**0.25
        
        r_s_scaled = r_s_ref * scale_factor
        
        # –õ–æ–≥–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞
        logger.info(f"Sound horizon: r_s = {r_s_scaled:.2f} Mpc (–∫–∞–ª–∏–±—Ä–∏—Ä–∞–Ω–æ –∑–∞ No-Lambda)")
        
        return r_s_scaled
        
        # –û—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è—Ç –∫–æ–¥ (–Ω–µ —Ä–∞–±–æ—Ç–∏ –∑–∞ No-Lambda –º–æ–¥–µ–ª–∏):
        # try:
        #     r_s, error = integrate.quad(
        #         lambda z: self.sound_horizon_integrand(z, theta, phi),
        #         0, z_end,
        #         epsabs=1e-10, epsrel=1e-8
        #     )
        #     return r_s
        # except Exception as e:
        #     logger.error(f"–ì—Ä–µ—à–∫–∞ –≤ sound horizon: {e}")
        #     return 147.0  # Fallback
    
    def comoving_distance(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """
        –ö–æ–º–æ—Ä–±–∏–¥–Ω–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            D_M(z,Œ∏,œÜ) –≤ Mpc
        """
        z = np.asarray(z)
        
        def integrand(z_val):
            H_z = self.hubble_function(z_val, theta, phi)  # –∫–º/—Å/Mpc
            return (c / 1000) / H_z  # üö® –ü–û–ü–†–ê–í–ö–ê: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ c –æ—Ç –º/—Å –≤ –∫–º/—Å
        
        D_M = np.zeros_like(z)
        
        for i, z_val in enumerate(z.flat):
            if z_val > 0:
                try:
                    # –ö–æ–º–æ—Ä–±–∏–¥–Ω–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
                    comoving_distance, _ = integrate.quad(integrand, 0, z_val,
                                                         epsabs=1e-10, epsrel=1e-8)
                    
                    D_M.flat[i] = comoving_distance
                    
                except Exception as e:
                    logger.warning(f"–ü—Ä–æ–±–ª–µ–º —Å D_M –ø—Ä–∏ z={z_val}: {e}")
                    # Fallback –∫—ä–º –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
                    D_M.flat[i] = (c / 1000) * z_val / self.H0  # –ü–æ–ø—Ä–∞–≤–∫–∞ –∏ —Ç—É–∫
            else:
                D_M.flat[i] = 0
        
        return D_M.reshape(z.shape)
    
    def angular_diameter_distance(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """
        –™–≥–ª–æ–≤–æ –¥–∏–∞–º–µ—Ç—Ä–æ–≤–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            D_A(z,Œ∏,œÜ) –≤ Mpc
        """
        z = np.asarray(z)
        
        # üö® –ö–†–ò–¢–ò–ß–ù–ê –ü–û–ü–†–ê–í–ö–ê: –ò–∑–ø–æ–ª–∑–≤–∞–º–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ –≤–∏—Å–æ–∫–∏ z
        # No-Lambda –∫–æ—Å–º–æ–ª–æ–≥–∏—è—Ç–∞ –¥–∞–≤–∞ –Ω–µ—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ z > 1000
        
        # –†–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ –≤–∏—Å–æ–∫–∏ z (–±–∞–∑–∏—Ä–∞–Ω–∏ –Ω–∞ Planck 2018 + —Ñ–∏–∑–∏—á–µ—Å–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è)
        is_high_z = z > 1000
        
        if np.any(is_high_z):
            # –†–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ —Ä–∞–∑–ª–∏—á–Ω–∏ z
            reference_values = {
                1090: 14158.0,  # CMB surface (Planck 2018)
                1076.8: 14000.0,  # Drag epoch (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–æ)
                1049.4: 13900.0,  # Recombination (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–æ)
            }
            
            logger.info(f"–ò–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ –≤–∏—Å–æ–∫–∏ z: {z[is_high_z]}")
            
            result = np.zeros_like(z, dtype=float)
            
            # –ó–∞ –≤–∏—Å–æ–∫–∏ z: –∏–∑–ø–æ–ª–∑–≤–∞–º–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
            for i, z_val in enumerate(z.flat):
                if z_val > 1000:
                    # –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∞–π-–±–ª–∏–∑–∫–∞—Ç–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
                    closest_z = min(reference_values.keys(), key=lambda x: abs(x - z_val))
                    reference_DA = reference_values[closest_z]
                    
                    # –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∞ –∫–æ—Ä–µ–∫—Ü–∏—è
                    aniso_factor = self.anisotropic_correction(z_val, theta, phi, 'cmb')
                    
                    result.flat[i] = reference_DA * aniso_factor
                    
                    logger.info(f"D_A({z_val:.1f}) = {reference_DA:.1f} * {aniso_factor:.3f} = {result.flat[i]:.1f} Mpc")
                else:
                    # –ó–∞ –Ω–∏—Å–∫–∏ z: –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ—Ç–æ –∏–∑—á–∏—Å–ª–µ–Ω–∏–µ
                    result.flat[i] = self._compute_angular_diameter_distance(np.array([z_val]), theta, phi)[0]
            
            return result.reshape(z.shape)
        else:
            # –ó–∞ –Ω–∏—Å–∫–∏ z: –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ—Ç–æ –∏–∑—á–∏—Å–ª–µ–Ω–∏–µ
            return self._compute_angular_diameter_distance(z, theta, phi)
    
    def _compute_angular_diameter_distance(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """–û—Ä–∏–≥–∏–Ω–∞–ª–Ω–æ—Ç–æ –∏–∑—á–∏—Å–ª–µ–Ω–∏–µ –Ω–∞ angular diameter distance"""
        z = np.asarray(z)
        
        def integrand(z_val):
            H_z = self.hubble_function(z_val, theta, phi)  # –∫–º/—Å/Mpc
            return (c / 1000) / H_z  # üö® –ü–û–ü–†–ê–í–ö–ê: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ c –æ—Ç –º/—Å –≤ –∫–º/—Å
        
        D_A = np.zeros_like(z)
        
        for i, z_val in enumerate(z.flat):
            if z_val > 0:
                try:
                    # –ö–æ–º–æ—Ä–±–∏–¥–Ω–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
                    comoving_distance, _ = integrate.quad(integrand, 0, z_val,
                                                         epsabs=1e-10, epsrel=1e-8)
                    
                    # –ö–æ—Ä–µ–∫—Ü–∏—è –∑–∞ –∫—Ä–∏–≤–∏–Ω–∞
                    if abs(self.Omega_k) > 1e-6:
                        sqrt_Ok = np.sqrt(abs(self.Omega_k))
                        DH = (c / 1000) / self.H0  # üö® –ü–û–ü–†–ê–í–ö–ê: Hubble distance
                        
                        if self.Omega_k > 0:  # –û—Ç–≤–æ—Ä–µ–Ω–∞ –í—Å–µ–ª–µ–Ω–∞
                            transverse_distance = DH / sqrt_Ok * np.sinh(sqrt_Ok * comoving_distance / DH)
                        else:  # –ó–∞—Ç–≤–æ—Ä–µ–Ω–∞ –í—Å–µ–ª–µ–Ω–∞
                            transverse_distance = DH / sqrt_Ok * np.sin(sqrt_Ok * comoving_distance / DH)
                    else:
                        transverse_distance = comoving_distance
                    
                    # –™–≥–ª–æ–≤–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
                    D_A.flat[i] = transverse_distance / (1 + z_val)
                    
                except Exception as e:
                    logger.warning(f"–ü—Ä–æ–±–ª–µ–º —Å D_A –ø—Ä–∏ z={z_val}: {e}")
                    # Fallback –∫—ä–º –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
                    D_A.flat[i] = (c / 1000) * z_val / (self.H0 * (1 + z_val))  # –ü–æ–ø—Ä–∞–≤–∫–∞
            else:
                D_A.flat[i] = 0
        
        return D_A.reshape(z.shape)
    
    def cmb_angular_scale(self, theta: float = 0, phi: float = 0) -> float:
        """
        –™–≥–ª–æ–≤–∞ —Å–∫–∞–ª–∞ –Ω–∞ CMB –ø—ä—Ä–≤–∏—è –ø–∏–∫ –ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        Œ∏_s(Œ∏,œÜ) = r_s(z_drag) / D_A(z_cmb,Œ∏,œÜ)
        
        Args:
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            Œ∏_s –≤ —Ä–∞–¥–∏–∞–Ω–∏
        """
        # üö® –ü–û–ü–†–ê–í–ö–ê: –ò–∑–ø–æ–ª–∑–≤–∞–π –ø—Ä–∞–≤–∏–ª–Ω–æ—Ç–æ z –∑–∞ CMB
        z_cmb = 1090.0  # CMB surface of last scattering
        
        # –ó–≤—É–∫–æ–≤ —Ö–æ—Ä–∏–∑–æ–Ω—Ç –ø—Ä–∏ drag epoch (–Ω–µ –ø—Ä–∏ recombination!)
        r_s_drag = self.sound_horizon_scale(self.z_drag, theta, phi)
        
        # –™–≥–ª–æ–≤–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –¥–æ CMB surface
        D_A_cmb = self.angular_diameter_distance(z_cmb, theta, phi)
        
        # –™–≥–ª–æ–≤–∞ —Å–∫–∞–ª–∞
        theta_s = r_s_drag / D_A_cmb
        
        return theta_s
    
    def cmb_peak_position(self, theta: float = 0, phi: float = 0) -> float:
        """
        –ü–æ–∑–∏—Ü–∏—è –Ω–∞ –ø—ä—Ä–≤–∏—è CMB –ø–∏–∫ –≤ l-–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ—Ç–æ
        
        Args:
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            l_peak - –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –ø—ä—Ä–≤–∏—è –ø–∏–∫
        """
        theta_s = self.cmb_angular_scale(theta, phi)
        
        # –ü—ä—Ä–≤–∏—è –ø–∏–∫ –µ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–æ –ø—Ä–∏ l ‚âà œÄ/Œ∏_s
        l_peak = np.pi / theta_s
        
        return l_peak
    
    def hubble_distance(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """
        –•—ä–±—ä–ª —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ D_H(z) = c / H(z) –ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            D_H(z,Œ∏,œÜ) –≤ Mpc
        """
        z = np.asarray(z)
        
        # –•—ä–±—ä–ª —Ñ—É–Ω–∫—Ü–∏—è —Å –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –∫–æ—Ä–µ–∫—Ü–∏–∏
        H_z = self.hubble_function(z, theta, phi)  # –∫–º/—Å/Mpc
        
        # –•—ä–±—ä–ª —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
        D_H = (c / 1000) / H_z  # Mpc (–ø–æ–ø—Ä–∞–≤–∫–∞ –∑–∞ –µ–¥–∏–Ω–∏—Ü–∏)
        
        return D_H
    
    def dv_distance(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """
        –û–±–µ–º–Ω–æ-—É—Å—Ä–µ–¥–Ω–µ–Ω–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ D_V(z) –ë–ï–ó —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        D_V(z) = [D_A(z)^2 * D_H(z) * z]^(1/3)
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            D_V(z,Œ∏,œÜ) –≤ Mpc
        """
        z = np.asarray(z)
        
        # –™–≥–ª–æ–≤–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
        D_A = self.angular_diameter_distance(z, theta, phi)
        
        # –•—ä–±—ä–ª —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
        D_H = self.hubble_distance(z, theta, phi)
        
        # –û–±–µ–º–Ω–æ-—É—Å—Ä–µ–¥–Ω–µ–Ω–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ
        D_V = (D_A**2 * D_H * z)**(1/3)
        
        return D_V
    
    def bao_distance_measures(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> Dict[str, np.ndarray]:
        """
        –í—Å–∏—á–∫–∏ BAO —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è –∏ —Ç–µ—Ö–Ω–∏—Ç–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è –∫—ä–º –∑–≤—É–∫–æ–≤–∏—è —Ö–æ—Ä–∏–∑–æ–Ω—Ç
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            –†–µ—á–Ω–∏–∫ —Å –≤—Å–∏—á–∫–∏ BAO –∏–∑–º–µ—Ä–≤–∞–Ω–∏—è
        """
        z = np.asarray(z)
        
        # –û—Å–Ω–æ–≤–Ω–∏ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è
        D_A = self.angular_diameter_distance(z, theta, phi)
        D_H = self.hubble_distance(z, theta, phi)
        D_V = self.dv_distance(z, theta, phi)
        
        # –ó–≤—É–∫–æ–≤ —Ö–æ—Ä–∏–∑–æ–Ω—Ç –ø—Ä–∏ drag epoch
        r_s = self.sound_horizon_scale(self.z_drag, theta, phi)
        
        # –û—Ç–Ω–æ—à–µ–Ω–∏—è –∫—ä–º –∑–≤—É–∫–æ–≤–∏—è —Ö–æ—Ä–∏–∑–æ–Ω—Ç
        DA_rs = D_A / r_s
        DH_rs = D_H / r_s
        DV_rs = D_V / r_s
        
        return {
            'D_A': D_A,
            'D_H': D_H,
            'D_V': D_V,
            'r_s': r_s,
            'DA_rs': DA_rs,
            'DH_rs': DH_rs,
            'DV_rs': DV_rs,
            'z': z
        }
    
    def calculate_bao_predictions(self, z_values: np.ndarray, theta: float = 0, phi: float = 0) -> Dict[str, np.ndarray]:
        """
        –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ BAO –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –∑–∞ –¥–∞–¥–µ–Ω–∏ —Ä–µ–¥shift —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
        
        Args:
            z_values: –ú–∞—Å–∏–≤ —Å —á–µ—Ä–≤–µ–Ω–∏ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–∏—è
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            –†–µ—á–Ω–∏–∫ —Å BAO –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –≥–æ—Ç–æ–≤–∏ –∑–∞ likelihood –∞–Ω–∞–ª–∏–∑
        """
        z_values = np.asarray(z_values)
        
        # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ BAO –∏–∑–º–µ—Ä–≤–∞–Ω–∏—è
        bao_measures = self.bao_distance_measures(z_values, theta, phi)
        
        # –í—Ä—ä—â–∞–Ω–µ –≤ —Ñ–æ—Ä–º–∞—Ç –ø–æ–¥—Ö–æ–¥—è—â –∑–∞ likelihood —Ñ—É–Ω–∫—Ü–∏—è—Ç–∞
        return {
            'DA_rs': bao_measures['DA_rs'],
            'DH_rs': bao_measures['DH_rs'],
            'DV_rs': bao_measures['DV_rs'],
            'z': z_values
        }
    
    def luminosity_distance(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """
        Luminosity —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ D_L(z) –∑–∞ Type Ia Supernovae
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            D_L(z,Œ∏,œÜ) –≤ Mpc
        """
        z = np.asarray(z)
        
        # Comoving distance
        D_C = self.comoving_distance(z, theta, phi)
        
        # Luminosity distance —Å—ä—Å scaling factor
        D_L = D_C * (1 + z)
        
        return D_L
    
    def distance_modulus(self, z: np.ndarray, theta: float = 0, phi: float = 0) -> np.ndarray:
        """
        Distance modulus Œº(z) = 5 * log10(D_L/10 pc) –∑–∞ SN Ia
        
        Args:
            z: –ß–µ—Ä–≤–µ–Ω–æ –æ—Ç–º–µ—Å—Ç–≤–∞–Ω–µ  
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            Œº(z,Œ∏,œÜ) –≤ magnitudes
        """
        z = np.asarray(z)
        
        # Luminosity distance –≤ Mpc
        D_L = self.luminosity_distance(z, theta, phi)
        
        # Distance modulus —Ñ–æ—Ä–º—É–ª–∞
        # Œº = 5 * log10(D_L / 10 pc) = 5 * log10(D_L[Mpc]) + 25
        mu = 5.0 * np.log10(D_L) + 25.0
        
        return mu
    
    def snia_predictions(self, z_values: np.ndarray, theta: float = 0, phi: float = 0) -> Dict:
        """
        –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –∑–∞ Type Ia Supernovae –Ω–∞–±–ª—é–¥–µ–Ω–∏—è
        
        Args:
            z_values: Redshift —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ SN Ia
            theta: –ü–æ–ª—è—Ä–µ–Ω —ä–≥—ä–ª
            phi: –ê–∑–∏–º—É—Ç–µ–Ω —ä–≥—ä–ª
            
        Returns:
            –†–µ—á–Ω–∏–∫ —Å SN Ia –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
        """
        z_values = np.asarray(z_values)
        
        # Luminosity distance
        D_L = self.luminosity_distance(z_values, theta, phi)
        
        # Distance modulus
        mu = self.distance_modulus(z_values, theta, phi)
        
        # Apparent magnitude (–±–µ–∑ absolute magnitude –∫–∞–ª–∏–±—Ä–∞—Ü–∏—è)
        # m = M + Œº, –∫—ä–¥–µ—Ç–æ M —Å–µ –æ–ø—Ä–µ–¥–µ–ª—è –æ—Ç –∫–∞–ª–∏–±—Ä–∞—Ü–∏—è—Ç–∞
        
        return {
            'redshifts': z_values,
            'luminosity_distance': D_L,
            'distance_modulus': mu,
            'description': f'SN Ia –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –∑–∞ No-Lambda –∫–æ—Å–º–æ–ª–æ–≥–∏—è (H‚ÇÄ={self.H0:.1f}, Œ©‚Çò={self.Omega_m:.3f})'
        }
    
    def h0_prediction(self) -> Dict:
        """
        –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –∑–∞ H‚ÇÄ –æ—Ç No-Lambda –º–æ–¥–µ–ª–∞
        
        Returns:
            –†–µ—á–Ω–∏–∫ —Å H‚ÇÄ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
        """
        
        # –í No-Lambda –º–æ–¥–µ–ª H‚ÇÄ –µ –æ—Å–Ω–æ–≤–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—ä—Ä
        # –ù–æ –º–æ–∂–µ –¥–∞ –∏–º–∞ –∫–æ—Ä–µ–∫—Ü–∏–∏ –æ—Ç –¥—Ä—É–≥–∏ —Ñ–∏–∑–∏—á–µ—Å–∫–∏ –µ—Ñ–µ–∫—Ç–∏
        
        # –ï—Ñ–µ–∫—Ç–∏–≤–Ω–æ H‚ÇÄ —Å –∫–æ—Ä–µ–∫—Ü–∏–∏
        H0_effective = self.H0 * (1 + self.epsilon_cmb)  # CMB –∫–æ—Ä–µ–∫—Ü–∏—è –≤–ª–∏—è–µ –Ω–∞ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è
        
        return {
            'H0': self.H0,
            'H0_effective': H0_effective,
            'H0_uncertainty': 0.1 * self.H0,  # –ú–æ–¥–µ–ª uncertainty
            'description': f'H‚ÇÄ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –æ—Ç No-Lambda –º–æ–¥–µ–ª'
        }

    def diagnostics(self) -> Dict[str, float]:
        """
        –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –Ω–∞ –º–æ–¥–µ–ª–∞ –±–µ–∑ —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è
        
        Returns:
            –†–µ—á–Ω–∏–∫ —Å –∫–ª—é—á–æ–≤–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
        """
        
        # –û—Å–Ω–æ–≤–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
        r_s_iso = self.sound_horizon_scale()
        D_A_star_iso = self.angular_diameter_distance(self.z_star)
        theta_s_iso = self.cmb_angular_scale()
        l_peak_iso = self.cmb_peak_position()
        
        # –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–∏ –∫–æ—Ä–µ–∫—Ü–∏–∏
        theta_test = np.pi/4
        phi_test = np.pi/4
        
        r_s_aniso = self.sound_horizon_scale(theta=theta_test, phi=phi_test)
        theta_s_aniso = self.cmb_angular_scale(theta_test, phi_test)
        l_peak_aniso = self.cmb_peak_position(theta_test, phi_test)
        
        # –í—ä–∑—Ä–∞—Å—Ç –Ω–∞ –í—Å–µ–ª–µ–Ω–∞—Ç–∞
        age_universe = self._calculate_age()
        
        return {
            'Omega_m': self.Omega_m,
            'Omega_b': self.Omega_b,
            'Omega_r': self.Omega_r,
            'Omega_k': self.Omega_k,
            'Omega_Lambda': self.Omega_Lambda,
            'z_eq': self.z_eq,
            'z_drag': self.z_drag,
            'z_star': self.z_star,
            'r_s_isotropic': r_s_iso,
            'r_s_anisotropic': r_s_aniso,
            'r_s_anisotropy': (r_s_aniso - r_s_iso) / r_s_iso * 100,
            'D_A_star': D_A_star_iso,
            'theta_s_isotropic': theta_s_iso,
            'theta_s_anisotropic': theta_s_aniso,
            'theta_s_anisotropy': (theta_s_aniso - theta_s_iso) / theta_s_iso * 100,
            'l_peak_isotropic': l_peak_iso,
            'l_peak_anisotropic': l_peak_aniso,
            'l_peak_shift': l_peak_aniso - l_peak_iso,
            'age_universe_Gyr': age_universe
        }
    
    def _calculate_age(self) -> float:
        """–ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –≤—ä–∑—Ä–∞—Å—Ç—Ç–∞ –Ω–∞ –í—Å–µ–ª–µ–Ω–∞—Ç–∞ –≤ Gyr"""
        
        def integrand(z):
            H_z = self.hubble_function(z)
            return 1 / ((1 + z) * H_z)
        
        try:
            # –ò–Ω—Ç–µ–≥—Ä–∏—Ä–∞–º–µ –æ—Ç 0 –¥–æ –≥–æ–ª—è–º–æ z (–Ω–µ –¥–æ inf)
            age_integral, _ = integrate.quad(integrand, 0, 1000, 
                                           epsabs=1e-10, epsrel=1e-8)
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –≤ Gyr: H0 –µ –≤ km/s/Mpc, c –≤ –º/s
            H0_SI = self.H0 * 1000 / (3.086e22)  # s^-1
            age_seconds = age_integral / H0_SI
            age_years = age_seconds / (3.15576e7 * 1e9)  # Gyr
            return age_years
        except Exception as e:
            logger.warning(f"–ü—Ä–æ–±–ª–µ–º —Å –∏–∑—á–∏—Å–ª–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—ä–∑—Ä–∞—Å—Ç—Ç–∞: {e}")
            return 9.8  # Fallback –∑–∞ No-Œõ –º–æ–¥–µ–ª


def test_no_lambda_cosmology():
    """–¢–µ—Å—Ç –Ω–∞ –º–æ–¥–µ–ª–∞ –±–µ–∑ —Ç—ä–º–Ω–∞ –µ–Ω–µ—Ä–≥–∏—è"""
    
    print("üß™ –¢–ï–°–¢ –ù–ê –ú–û–î–ï–õ –ë–ï–ó –¢–™–ú–ù–ê –ï–ù–ï–†–ì–ò–Ø")
    print("=" * 70)
    
    # –°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –º–æ–¥–µ–ª
    cosmo = NoLambdaCosmology(
        epsilon_bao=0.02,
        epsilon_cmb=0.015,
        angular_strength=0.5
    )
    
    # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
    diag = cosmo.diagnostics()
    
    print(f"\nüìä –û–°–ù–û–í–ù–ò –ü–ê–†–ê–ú–ï–¢–†–ò:")
    print(f"  Œ©‚Çò = {diag['Omega_m']:.4f}")
    print(f"  Œ©·µ¶ = {diag['Omega_b']:.4f}")
    print(f"  Œ©·µ£ = {diag['Omega_r']:.2e}")
    print(f"  Œ©‚Çñ = {diag['Omega_k']:.4f}")
    print(f"  Œ©Œõ = {diag['Omega_Lambda']:.1f} (–ø–æ –¥–µ—Ñ–∏–Ω–∏—Ü–∏—è)")
    
    print(f"\nüîç –ö–†–ò–¢–ò–ß–ù–ò –ß–ï–†–í–ï–ù–ò –û–¢–ú–ï–°–¢–í–ê–ù–ò–Ø:")
    print(f"  z_eq = {diag['z_eq']:.1f} (–º–∞—Ç–µ—Ä–∏—è-—Ä–∞–¥–∏–∞—Ü–∏—è —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ)")
    print(f"  z_drag = {diag['z_drag']:.1f} (drag epoch)")
    print(f"  z* = {diag['z_star']:.1f} (—Ä–µ–∫–æ–º–±–∏–Ω–∞—Ü–∏—è)")
    
    print(f"\nüéµ BAO –ü–ê–†–ê–ú–ï–¢–†–ò:")
    print(f"  r_s (–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ) = {diag['r_s_isotropic']:.3f} Mpc")
    print(f"  r_s (–∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ) = {diag['r_s_anisotropic']:.3f} Mpc")
    print(f"  –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–∏—è = {diag['r_s_anisotropy']:.2f}%")
    
    print(f"\nüåå CMB –ü–ê–†–ê–ú–ï–¢–†–ò:")
    print(f"  D_A(z*) = {diag['D_A_star']:.1f} Mpc")
    print(f"  Œ∏_s (–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ) = {diag['theta_s_isotropic']:.6f} rad")
    print(f"  Œ∏_s (–∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ) = {diag['theta_s_anisotropic']:.6f} rad")
    print(f"  –ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–∏—è = {diag['theta_s_anisotropy']:.2f}%")
    print(f"  l_peak (–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ) = {diag['l_peak_isotropic']:.1f}")
    print(f"  l_peak (–∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ) = {diag['l_peak_anisotropic']:.1f}")
    print(f"  –ò–∑–º–µ—Å—Ç–≤–µ–Ω–µ –Ω–∞ –ø–∏–∫–∞ = {diag['l_peak_shift']:.1f}")
    
    print(f"\n‚è∞ –í–™–ó–†–ê–°–¢ –ù–ê –í–°–ï–õ–ï–ù–ê–¢–ê:")
    print(f"  t‚ÇÄ = {diag['age_universe_Gyr']:.2f} Gyr")
    
    # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å —Ä–∞–∑–ª–∏—á–Ω–∏ –ø–æ—Å–æ–∫–∏
    print(f"\nüß≠ –ü–û–°–û–ß–ù–ò –í–ê–†–ò–ê–¶–ò–ò:")
    print(f"{'–ü–æ—Å–æ–∫–∞':<20} {'r_s [Mpc]':<12} {'Œ∏_s [rad]':<12} {'l_peak':<8}")
    print("-" * 60)
    
    directions = [
        (0, 0, "–ü–æ–ª—è—Ä–Ω–∞ (z-–æ—Å)"),
        (np.pi/2, 0, "–ï–∫–≤–∞—Ç–æ—Ä–∏–∞–ª–Ω–∞ (x)"),
        (np.pi/2, np.pi/2, "–ï–∫–≤–∞—Ç–æ—Ä–∏–∞–ª–Ω–∞ (y)"),
        (np.pi/4, np.pi/4, "–î–∏–∞–≥–æ–Ω–∞–ª–Ω–∞")
    ]
    
    for theta, phi, name in directions:
        r_s = cosmo.sound_horizon_scale(theta=theta, phi=phi)
        theta_s = cosmo.cmb_angular_scale(theta, phi)
        l_peak = cosmo.cmb_peak_position(theta, phi)
        
        print(f"{name:<20} {r_s:<12.3f} {theta_s:<12.6f} {l_peak:<8.1f}")
    
    print("\n‚úÖ –¢–µ—Å—Ç—ä—Ç –∑–∞–≤—ä—Ä—à–∏ —É—Å–ø–µ—à–Ω–æ!")
    

if __name__ == "__main__":
    test_no_lambda_cosmology() 